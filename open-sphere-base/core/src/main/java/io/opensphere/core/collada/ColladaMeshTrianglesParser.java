package io.opensphere.core.collada;

import java.awt.Color;
import java.util.Collection;
import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

import org.apache.log4j.Logger;

import io.opensphere.core.collada.jaxb.Geometry;
import io.opensphere.core.collada.jaxb.Image;
import io.opensphere.core.collada.jaxb.Input;
import io.opensphere.core.collada.jaxb.Mesh;
import io.opensphere.core.collada.jaxb.Triangles;
import io.opensphere.core.geometry.AbstractGeometry;
import io.opensphere.core.geometry.ImageManager;
import io.opensphere.core.geometry.PolygonMeshGeometry;
import io.opensphere.core.geometry.constraint.Constraints;
import io.opensphere.core.geometry.renderproperties.PolygonMeshRenderProperties;
import io.opensphere.core.image.ImageProvider;
import io.opensphere.core.math.Matrix4d;
import io.opensphere.core.math.Vector2d;
import io.opensphere.core.model.ModelPosition;
import io.opensphere.core.util.ColorUtilities;
import io.opensphere.core.util.collections.CollectionUtilities;
import io.opensphere.core.util.lang.Pair;

/**
 * Parser for COLLADA mesh triangles.
 */
class ColladaMeshTrianglesParser
{
    /** Logger reference. */
    private static final Logger LOGGER = Logger.getLogger(ColladaMeshTrianglesParser.class);

    /**
     * The constraints to be used in the result geometries.
     */
    private final Constraints myConstraints;

    /**
     * Render properties for polyline geometries generated by this parser.
     */
    private final PolygonMeshRenderProperties myPolygonMeshProperties;

    /** The image provider. */
    private final ImageProvider<Pair<Image, UUID>> myImageProvider;

    /**
     * Constructor.
     *
     * @param polygonMeshProperties The polygon mesh properties.
     * @param constraints The constraints.
     * @param imageProvider the image provider
     */
    public ColladaMeshTrianglesParser(PolygonMeshRenderProperties polygonMeshProperties, Constraints constraints,
            ImageProvider<Pair<Image, UUID>> imageProvider)
    {
        myPolygonMeshProperties = polygonMeshProperties;
        myConstraints = constraints;
        myImageProvider = imageProvider;
    }

    /**
     * Parses a COLLADA mesh and generates {@link PolygonMeshGeometry}s.
     *
     * @param geomInfo The geometry info.
     * @param matrix Optional transform matrix to be applied to the geometries'
     *            coordinates.
     * @param results The return collection.
     * @return {@code true} if any geometries were produced.
     */
    public boolean parseGeometryTriangles(GeometryInfo geomInfo, Matrix4d matrix, Collection<? super AbstractGeometry> results)
    {
        boolean foundSomething = false;
        Geometry geom = geomInfo.getGeometry();
        if (CollectionUtilities.hasContent(geomInfo.getShapes()))
        {
            List<ShapeInfo<?>> shapes = geomInfo.getShapes().stream().filter(s -> s.getShape() instanceof Triangles)
                    .collect(Collectors.toList());
            for (ShapeInfo<?> shape : shapes)
            {
                @SuppressWarnings("unchecked")
                ShapeInfo<Triangles> triangle = (ShapeInfo<Triangles>)shape;
                if (triangle.getShape().getPrimitives() == null)
                {
                    LOGGER.warn("Triangles with no primitives found for geometry " + geom.getId());
                }
                else
                {
                    results.add(parseGeometryTriangles(geomInfo.getGeometry(), triangle, matrix));
                    foundSomething = true;
                }
            }
        }
        return foundSomething;
    }

    /**
     * Parses a COLLADA "triangles" model and generates a
     * {@link PolygonMeshGeometry}s.
     *
     * @param geometry The COLLADA geometry.
     * @param triangle The triangle to be processed.
     * @param matrix Optional transform matrix to be applied to the geometries'
     *            coordinates.
     * @return The result geometry or {@code null} if one was not produced.
     */
    private PolygonMeshGeometry parseGeometryTriangles(Geometry geometry, ShapeInfo<Triangles> triangle, Matrix4d matrix)
    {
        Triangles triangles = triangle.getShape();

        Optional<Input> vertexInput = triangles.getInputs().stream().filter(i -> "VERTEX".equals(i.getSemantic())).findAny();
        if (!vertexInput.isPresent())
        {
            LOGGER.warn("No vertex input found for geometry " + geometry.getId());
            return null;
        }

        Mesh mesh = geometry.getMesh();
        String positionSourceId = ColladaUtilities.getVerticesIdToSourceIdMap(mesh, "POSITION")
                .get(vertexInput.get().getSource());

        float[] positionData = ColladaUtilities.getDataFromSources(mesh, positionSourceId);
        if (positionData == null)
        {
            LOGGER.warn("No position data found for geometry " + geometry.getId() + " with tag " + positionSourceId);
            return null;
        }

        int vertexOffset = vertexInput.get().getOffset();
        int maxOffset = triangles.getInputs().stream().mapToInt(i -> i.getOffset()).max().getAsInt();
        int[] primitives = triangles.getPrimitives();
        PolygonMeshGeometry.Builder<ModelPosition> polyBuilder = new PolygonMeshGeometry.Builder<>();
        polyBuilder.setPolygonVertexCount(3);
        polyBuilder.setPositions(ColladaUtilities.getPositions(vertexOffset, maxOffset + 1, positionData, primitives, matrix));

        Optional<Input> normalInput = triangles.getInputs().stream().filter(i -> "NORMAL".equals(i.getSemantic())).findAny();
        String normalSourceId;
        int normalOffset;
        if (normalInput.isPresent())
        {
            normalSourceId = normalInput.get().getSource();
            normalOffset = normalInput.get().getOffset();
        }
        else
        {
            normalSourceId = ColladaUtilities.getVerticesIdToSourceIdMap(mesh, "NORMAL").get(vertexInput.get().getSource());
            normalOffset = vertexOffset;
        }

        if (normalSourceId != null)
        {
            float[] normalData = ColladaUtilities.getDataFromSources(mesh, normalSourceId);
            polyBuilder.setNormals(ColladaUtilities.getNormals(normalOffset, maxOffset + 1, normalData, primitives, matrix));
        }
        else
        {
            polyBuilder.setNormals(null);
        }

        polyBuilder.setDataModelId(geometry.hashCode());

        PolygonMeshRenderProperties renderProps = myPolygonMeshProperties;
        if (myImageProvider != null)
        {
            Image colladaImage = triangle.getImage();
            if (colladaImage != null)
            {
                Pair<Image, UUID> key = new Pair<>(colladaImage, UUID.randomUUID());
                polyBuilder.setImageManager(new ImageManager(key, myImageProvider));
                List<Vector2d> textureCoords = getTextureCoords(geometry, triangles);
                if (LOGGER.isDebugEnabled())
                {
                    LOGGER.debug(textureCoords);
                }
                polyBuilder.setTextureCoords(textureCoords);
            }
            else
            {
                String colorString = triangle.getEffect().getProfileCommon().getTechnique().getColor();
                Color color = ColladaUtilities.parseColor(colorString);
                if (color != null)
                {
                    // Google Earth does approximately this
                    if (color.getAlpha() == 0)
                    {
                        color = ColorUtilities.opacitizeColor(color, 100);
                    }

                    renderProps = (PolygonMeshRenderProperties)myPolygonMeshProperties.clone();
                    renderProps.setColor(color);
                }
            }
        }

        return new PolygonMeshGeometry(polyBuilder, renderProps, myConstraints);
    }

    /**
     * Gets the texture coordinates for the triangle.
     *
     * @param geometry the geometry
     * @param triangle the triangle
     * @return the texture coordinates
     */
    private List<Vector2d> getTextureCoords(Geometry geometry, Triangles triangle)
    {
        List<float[]> texCoordData = ColladaUtilities.getSourceData(triangle.getInputs(), triangle.getPrimitives(), geometry,
                "TEXCOORD");
        return texCoordData.stream().map(tc -> new Vector2d(tc[0], 1 - tc[1])).collect(Collectors.toList());
    }
}
